1) Single responsibility: у каждого класса есть только одно предназначение. Разбивай большие задачи на подзадачи, делай сложное простым
2) Opened/closed: Сущности (классы, модули, функции) должны быть расширяемы, но закрыты для изменений
3) Liskov substitution: наследники должны уметь заменять родителей (т.е. сохранять свойства и поведение родителя, расширяя его).
Пример: нельзя заменить прямоугольник квадратом, но можно добавить для них общую сущность - форму
4) Interface Segregation: не привязывай к классу несвязанный с ним интерфейс. (Не привязывать классу то, чем он не пользуется)
5) Dependency Inversion: высокоуровневые классы не должны зависеть от низкоуровневых. Все они завязаны на абстракциях
(исполнители должны соединяться с инструментами через интерфейсы, интерфейсы строятся на абстракциях)