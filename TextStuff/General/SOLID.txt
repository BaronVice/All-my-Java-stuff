1) Single responsibility: у каждого класса есть только одно предназначение и одна цель меняться.
2) Opened/closed: Сущности (классы, модули, функции) должны быть расширяемы, но закрыты для изменений.
Здесь либо разбивать на отдельные классы, либо подключать новые инструкции через интерфейсы.
3) Liskov substitution: наследники должны уметь заменять родителей (т.е. сохранять свойства и поведение родителя, расширяя его).
Создаем какую-то общую абстрактную сущность, чтобы подклассы по-своему реализовали ее.
4) Interface Segregation: не привязывай к классу несвязанный с ним интерфейс. Лучше много простых интерфейсов,
чем один перегруженный всем подряд (Не привязывай классу поведение, которым он не пользуется)
P.S. также открывается возможность для использования лямбд (их можно использовать, когда у интерфейса один метод,
он же еще называется Functional Interface (там даже аннотация такая есть))
5) Dependency Inversion: высокоуровневые классы не должны зависеть от низкоуровневых. Все они завязаны на абстракциях
(иными словами: умей пользоваться интерфейсами и расставлять абстрактные методы в абстрактных классах)